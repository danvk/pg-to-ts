/**
 * Generate TypeScript interface definitions from your Postgres schema
 * pg-to-ts is derived from PYST/schemats, which was a fork of SweetIQ/schemats.
 */

import {generateEnumType, generateTableInterface} from './typescript';
import Options, {OptionValues} from './options';
import {processString, Options as ITFOptions} from 'typescript-formatter';
import {PostgresDatabase} from './schemaPostgres';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const pkgVersion = require('../package.json').version;

function buildHeader(
  db: PostgresDatabase,
  tables: string[],
  schema: string | null,
  options: OptionValues,
): string {
  const commands = [
    'pg-to-ts',
    'generate',
    '-c',
    db.connectionString.replace(/:\/\/.*@/, '://username:password@'),
  ];
  if (options.camelCase) commands.push('-C');
  if (tables.length > 0) {
    tables.forEach((t: string) => {
      commands.push('-t', t);
    });
  }
  if (schema) {
    commands.push('-s', schema);
  }

  return `
        /**
         * AUTO-GENERATED FILE - DO NOT EDIT!
         *
         * This file was automatically generated by pg-to-ts v.${pkgVersion}
         * $ ${commands.join(' ')}
         *
         */

    `;
}

export async function typescriptOfTable(
  db: PostgresDatabase,
  table: string,
  schema: string,
  options = new Options(),
) {
  const tableTypes = await db.getTableTypes(table, schema, options);
  return generateTableInterface(table, tableTypes, schema, options);
}

export async function typescriptOfSchema(
  dbIn: PostgresDatabase | string,
  tables: string[] = [],
  excludedTables: string[] = [],
  inSchema: string | null = null,
  options: OptionValues = {},
): Promise<string> {
  const db = typeof dbIn === 'string' ? new PostgresDatabase(dbIn) : dbIn;
  const schema = inSchema ?? db.getDefaultSchema();

  if (tables.length === 0) {
    tables = (await db.getSchemaTables(schema)).filter(
      t => excludedTables.indexOf(t) == -1,
    );
  }

  const optionsObject = new Options(options);

  const enumTypes = generateEnumType(
    await db.getEnumTypes(schema),
    optionsObject,
  );
  const interfacePromises = tables.map(table =>
    typescriptOfTable(db, table, schema, optionsObject),
  );
  const interfaceTuples = await Promise.all(interfacePromises);

  const interfaces = interfaceTuples.map(([ts]) => ts).join('');
  const typesToImport = new Set<string>();
  for (const types of interfaceTuples.map(([, , types]) => types)) {
    types.forEach(typesToImport.add, typesToImport);
  }
  let importTs = '';
  if (options.jsonTypesFile && typesToImport.size) {
    const symbols = Array.from(typesToImport).join(', ');
    importTs = `import {${symbols}} from "${options.jsonTypesFile}";\n\n`;
  }

  const tableNames = interfaceTuples.map(([, names]) => names);
  const typeMaps = tableNames
    .map(
      names => `
    ${names.var}: {
      select: ${names.type};
      input: ${names.input};
    };`,
    )
    .join('');
  const tableMap = tableNames.map(names => names.var).join(',\n  ');

  let output = '/* tslint:disable */\n/* eslint-disable */\n\n';
  if (optionsObject.options.writeHeader) {
    output += buildHeader(db, tables, schema, options);
  }

  // TODO(danvk): This is a better type than unknown, but typescript-json-schema chokes on it.
  // type Json =
  // | string
  // | number
  // | boolean
  // | null
  // | { [property: string]: Json }
  // | Json[];

  output += importTs;
  output += `
  export type Json = unknown;
    `;

  output += enumTypes;
  output += interfaces;
  output += `

  export interface TableTypes {${typeMaps}
  }

  export const tables = {
    ${tableMap},
  }
  `;

  const formatterOption: ITFOptions = {
    replace: false,
    verify: false,
    tsconfig: true,
    tslint: true,
    editorconfig: true,
    tsfmt: true,
    vscode: false,
    tsconfigFile: null,
    tslintFile: null,
    vscodeFile: null,
    tsfmtFile: null,
  };

  const processedResult = await processString(
    'schema.ts',
    output,
    formatterOption,
  );
  return processedResult.dest.replace(/ {4}/g, '  ');
}

export {Database} from './schemaInterfaces';
export {Options, OptionValues};
